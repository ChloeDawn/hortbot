// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// Channel is an object representing the database table.
type Channel struct {
	ID                          int64             `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatedAt                   time.Time         `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt                   time.Time         `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	UserID                      int64             `boil:"user_id" json:"user_id" toml:"user_id" yaml:"user_id"`
	Name                        string            `boil:"name" json:"name" toml:"name" yaml:"name"`
	BotName                     string            `boil:"bot_name" json:"bot_name" toml:"bot_name" yaml:"bot_name"`
	Active                      bool              `boil:"active" json:"active" toml:"active" yaml:"active"`
	Prefix                      string            `boil:"prefix" json:"prefix" toml:"prefix" yaml:"prefix"`
	Bullet                      null.String       `boil:"bullet" json:"bullet,omitempty" toml:"bullet" yaml:"bullet,omitempty"`
	Ignored                     types.StringArray `boil:"ignored" json:"ignored" toml:"ignored" yaml:"ignored"`
	CustomOwners                types.StringArray `boil:"custom_owners" json:"custom_owners" toml:"custom_owners" yaml:"custom_owners"`
	CustomMods                  types.StringArray `boil:"custom_mods" json:"custom_mods" toml:"custom_mods" yaml:"custom_mods"`
	CustomRegulars              types.StringArray `boil:"custom_regulars" json:"custom_regulars" toml:"custom_regulars" yaml:"custom_regulars"`
	Cooldown                    null.Int          `boil:"cooldown" json:"cooldown,omitempty" toml:"cooldown" yaml:"cooldown,omitempty"`
	LastCommandAt               time.Time         `boil:"last_command_at" json:"last_command_at" toml:"last_command_at" yaml:"last_command_at"`
	LastFM                      string            `boil:"last_fm" json:"last_fm" toml:"last_fm" yaml:"last_fm"`
	ParseYoutube                bool              `boil:"parse_youtube" json:"parse_youtube" toml:"parse_youtube" yaml:"parse_youtube"`
	ExtraLifeID                 int               `boil:"extra_life_id" json:"extra_life_id" toml:"extra_life_id" yaml:"extra_life_id"`
	RaffleEnabled               bool              `boil:"raffle_enabled" json:"raffle_enabled" toml:"raffle_enabled" yaml:"raffle_enabled"`
	ShouldModerate              bool              `boil:"should_moderate" json:"should_moderate" toml:"should_moderate" yaml:"should_moderate"`
	DisplayWarnings             bool              `boil:"display_warnings" json:"display_warnings" toml:"display_warnings" yaml:"display_warnings"`
	EnableWarnings              bool              `boil:"enable_warnings" json:"enable_warnings" toml:"enable_warnings" yaml:"enable_warnings"`
	TimeoutDuration             int               `boil:"timeout_duration" json:"timeout_duration" toml:"timeout_duration" yaml:"timeout_duration"`
	EnableFilters               bool              `boil:"enable_filters" json:"enable_filters" toml:"enable_filters" yaml:"enable_filters"`
	FilterLinks                 bool              `boil:"filter_links" json:"filter_links" toml:"filter_links" yaml:"filter_links"`
	PermittedLinks              types.StringArray `boil:"permitted_links" json:"permitted_links" toml:"permitted_links" yaml:"permitted_links"`
	FilterCaps                  bool              `boil:"filter_caps" json:"filter_caps" toml:"filter_caps" yaml:"filter_caps"`
	FilterCapsMinChars          int               `boil:"filter_caps_min_chars" json:"filter_caps_min_chars" toml:"filter_caps_min_chars" yaml:"filter_caps_min_chars"`
	FilterCapsPercentage        int               `boil:"filter_caps_percentage" json:"filter_caps_percentage" toml:"filter_caps_percentage" yaml:"filter_caps_percentage"`
	FilterCapsMinCaps           int               `boil:"filter_caps_min_caps" json:"filter_caps_min_caps" toml:"filter_caps_min_caps" yaml:"filter_caps_min_caps"`
	FilterEmotes                bool              `boil:"filter_emotes" json:"filter_emotes" toml:"filter_emotes" yaml:"filter_emotes"`
	FilterEmotesMax             int               `boil:"filter_emotes_max" json:"filter_emotes_max" toml:"filter_emotes_max" yaml:"filter_emotes_max"`
	FilterEmotesSingle          bool              `boil:"filter_emotes_single" json:"filter_emotes_single" toml:"filter_emotes_single" yaml:"filter_emotes_single"`
	FilterSymbols               bool              `boil:"filter_symbols" json:"filter_symbols" toml:"filter_symbols" yaml:"filter_symbols"`
	FilterSymbolsPercentage     int               `boil:"filter_symbols_percentage" json:"filter_symbols_percentage" toml:"filter_symbols_percentage" yaml:"filter_symbols_percentage"`
	FilterSymbolsMinSymbols     int               `boil:"filter_symbols_min_symbols" json:"filter_symbols_min_symbols" toml:"filter_symbols_min_symbols" yaml:"filter_symbols_min_symbols"`
	FilterMe                    bool              `boil:"filter_me" json:"filter_me" toml:"filter_me" yaml:"filter_me"`
	FilterMaxLength             int               `boil:"filter_max_length" json:"filter_max_length" toml:"filter_max_length" yaml:"filter_max_length"`
	FilterBannedPhrases         bool              `boil:"filter_banned_phrases" json:"filter_banned_phrases" toml:"filter_banned_phrases" yaml:"filter_banned_phrases"`
	FilterBannedPhrasesPatterns types.StringArray `boil:"filter_banned_phrases_patterns" json:"filter_banned_phrases_patterns" toml:"filter_banned_phrases_patterns" yaml:"filter_banned_phrases_patterns"`

	R *channelR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L channelL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ChannelColumns = struct {
	ID                          string
	CreatedAt                   string
	UpdatedAt                   string
	UserID                      string
	Name                        string
	BotName                     string
	Active                      string
	Prefix                      string
	Bullet                      string
	Ignored                     string
	CustomOwners                string
	CustomMods                  string
	CustomRegulars              string
	Cooldown                    string
	LastCommandAt               string
	LastFM                      string
	ParseYoutube                string
	ExtraLifeID                 string
	RaffleEnabled               string
	ShouldModerate              string
	DisplayWarnings             string
	EnableWarnings              string
	TimeoutDuration             string
	EnableFilters               string
	FilterLinks                 string
	PermittedLinks              string
	FilterCaps                  string
	FilterCapsMinChars          string
	FilterCapsPercentage        string
	FilterCapsMinCaps           string
	FilterEmotes                string
	FilterEmotesMax             string
	FilterEmotesSingle          string
	FilterSymbols               string
	FilterSymbolsPercentage     string
	FilterSymbolsMinSymbols     string
	FilterMe                    string
	FilterMaxLength             string
	FilterBannedPhrases         string
	FilterBannedPhrasesPatterns string
}{
	ID:                          "id",
	CreatedAt:                   "created_at",
	UpdatedAt:                   "updated_at",
	UserID:                      "user_id",
	Name:                        "name",
	BotName:                     "bot_name",
	Active:                      "active",
	Prefix:                      "prefix",
	Bullet:                      "bullet",
	Ignored:                     "ignored",
	CustomOwners:                "custom_owners",
	CustomMods:                  "custom_mods",
	CustomRegulars:              "custom_regulars",
	Cooldown:                    "cooldown",
	LastCommandAt:               "last_command_at",
	LastFM:                      "last_fm",
	ParseYoutube:                "parse_youtube",
	ExtraLifeID:                 "extra_life_id",
	RaffleEnabled:               "raffle_enabled",
	ShouldModerate:              "should_moderate",
	DisplayWarnings:             "display_warnings",
	EnableWarnings:              "enable_warnings",
	TimeoutDuration:             "timeout_duration",
	EnableFilters:               "enable_filters",
	FilterLinks:                 "filter_links",
	PermittedLinks:              "permitted_links",
	FilterCaps:                  "filter_caps",
	FilterCapsMinChars:          "filter_caps_min_chars",
	FilterCapsPercentage:        "filter_caps_percentage",
	FilterCapsMinCaps:           "filter_caps_min_caps",
	FilterEmotes:                "filter_emotes",
	FilterEmotesMax:             "filter_emotes_max",
	FilterEmotesSingle:          "filter_emotes_single",
	FilterSymbols:               "filter_symbols",
	FilterSymbolsPercentage:     "filter_symbols_percentage",
	FilterSymbolsMinSymbols:     "filter_symbols_min_symbols",
	FilterMe:                    "filter_me",
	FilterMaxLength:             "filter_max_length",
	FilterBannedPhrases:         "filter_banned_phrases",
	FilterBannedPhrasesPatterns: "filter_banned_phrases_patterns",
}

// Generated where

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpertypes_StringArray struct{ field string }

func (w whereHelpertypes_StringArray) EQ(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_StringArray) NEQ(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_StringArray) LT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_StringArray) LTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_StringArray) GT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_StringArray) GTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var ChannelWhere = struct {
	ID                          whereHelperint64
	CreatedAt                   whereHelpertime_Time
	UpdatedAt                   whereHelpertime_Time
	UserID                      whereHelperint64
	Name                        whereHelperstring
	BotName                     whereHelperstring
	Active                      whereHelperbool
	Prefix                      whereHelperstring
	Bullet                      whereHelpernull_String
	Ignored                     whereHelpertypes_StringArray
	CustomOwners                whereHelpertypes_StringArray
	CustomMods                  whereHelpertypes_StringArray
	CustomRegulars              whereHelpertypes_StringArray
	Cooldown                    whereHelpernull_Int
	LastCommandAt               whereHelpertime_Time
	LastFM                      whereHelperstring
	ParseYoutube                whereHelperbool
	ExtraLifeID                 whereHelperint
	RaffleEnabled               whereHelperbool
	ShouldModerate              whereHelperbool
	DisplayWarnings             whereHelperbool
	EnableWarnings              whereHelperbool
	TimeoutDuration             whereHelperint
	EnableFilters               whereHelperbool
	FilterLinks                 whereHelperbool
	PermittedLinks              whereHelpertypes_StringArray
	FilterCaps                  whereHelperbool
	FilterCapsMinChars          whereHelperint
	FilterCapsPercentage        whereHelperint
	FilterCapsMinCaps           whereHelperint
	FilterEmotes                whereHelperbool
	FilterEmotesMax             whereHelperint
	FilterEmotesSingle          whereHelperbool
	FilterSymbols               whereHelperbool
	FilterSymbolsPercentage     whereHelperint
	FilterSymbolsMinSymbols     whereHelperint
	FilterMe                    whereHelperbool
	FilterMaxLength             whereHelperint
	FilterBannedPhrases         whereHelperbool
	FilterBannedPhrasesPatterns whereHelpertypes_StringArray
}{
	ID:                          whereHelperint64{field: "\"channels\".\"id\""},
	CreatedAt:                   whereHelpertime_Time{field: "\"channels\".\"created_at\""},
	UpdatedAt:                   whereHelpertime_Time{field: "\"channels\".\"updated_at\""},
	UserID:                      whereHelperint64{field: "\"channels\".\"user_id\""},
	Name:                        whereHelperstring{field: "\"channels\".\"name\""},
	BotName:                     whereHelperstring{field: "\"channels\".\"bot_name\""},
	Active:                      whereHelperbool{field: "\"channels\".\"active\""},
	Prefix:                      whereHelperstring{field: "\"channels\".\"prefix\""},
	Bullet:                      whereHelpernull_String{field: "\"channels\".\"bullet\""},
	Ignored:                     whereHelpertypes_StringArray{field: "\"channels\".\"ignored\""},
	CustomOwners:                whereHelpertypes_StringArray{field: "\"channels\".\"custom_owners\""},
	CustomMods:                  whereHelpertypes_StringArray{field: "\"channels\".\"custom_mods\""},
	CustomRegulars:              whereHelpertypes_StringArray{field: "\"channels\".\"custom_regulars\""},
	Cooldown:                    whereHelpernull_Int{field: "\"channels\".\"cooldown\""},
	LastCommandAt:               whereHelpertime_Time{field: "\"channels\".\"last_command_at\""},
	LastFM:                      whereHelperstring{field: "\"channels\".\"last_fm\""},
	ParseYoutube:                whereHelperbool{field: "\"channels\".\"parse_youtube\""},
	ExtraLifeID:                 whereHelperint{field: "\"channels\".\"extra_life_id\""},
	RaffleEnabled:               whereHelperbool{field: "\"channels\".\"raffle_enabled\""},
	ShouldModerate:              whereHelperbool{field: "\"channels\".\"should_moderate\""},
	DisplayWarnings:             whereHelperbool{field: "\"channels\".\"display_warnings\""},
	EnableWarnings:              whereHelperbool{field: "\"channels\".\"enable_warnings\""},
	TimeoutDuration:             whereHelperint{field: "\"channels\".\"timeout_duration\""},
	EnableFilters:               whereHelperbool{field: "\"channels\".\"enable_filters\""},
	FilterLinks:                 whereHelperbool{field: "\"channels\".\"filter_links\""},
	PermittedLinks:              whereHelpertypes_StringArray{field: "\"channels\".\"permitted_links\""},
	FilterCaps:                  whereHelperbool{field: "\"channels\".\"filter_caps\""},
	FilterCapsMinChars:          whereHelperint{field: "\"channels\".\"filter_caps_min_chars\""},
	FilterCapsPercentage:        whereHelperint{field: "\"channels\".\"filter_caps_percentage\""},
	FilterCapsMinCaps:           whereHelperint{field: "\"channels\".\"filter_caps_min_caps\""},
	FilterEmotes:                whereHelperbool{field: "\"channels\".\"filter_emotes\""},
	FilterEmotesMax:             whereHelperint{field: "\"channels\".\"filter_emotes_max\""},
	FilterEmotesSingle:          whereHelperbool{field: "\"channels\".\"filter_emotes_single\""},
	FilterSymbols:               whereHelperbool{field: "\"channels\".\"filter_symbols\""},
	FilterSymbolsPercentage:     whereHelperint{field: "\"channels\".\"filter_symbols_percentage\""},
	FilterSymbolsMinSymbols:     whereHelperint{field: "\"channels\".\"filter_symbols_min_symbols\""},
	FilterMe:                    whereHelperbool{field: "\"channels\".\"filter_me\""},
	FilterMaxLength:             whereHelperint{field: "\"channels\".\"filter_max_length\""},
	FilterBannedPhrases:         whereHelperbool{field: "\"channels\".\"filter_banned_phrases\""},
	FilterBannedPhrasesPatterns: whereHelpertypes_StringArray{field: "\"channels\".\"filter_banned_phrases_patterns\""},
}

// ChannelRels is where relationship names are stored.
var ChannelRels = struct {
	Autoreplies       string
	CustomCommands    string
	Quotes            string
	RepeatedCommands  string
	ScheduledCommands string
	Variables         string
}{
	Autoreplies:       "Autoreplies",
	CustomCommands:    "CustomCommands",
	Quotes:            "Quotes",
	RepeatedCommands:  "RepeatedCommands",
	ScheduledCommands: "ScheduledCommands",
	Variables:         "Variables",
}

// channelR is where relationships are stored.
type channelR struct {
	Autoreplies       AutoreplySlice
	CustomCommands    CustomCommandSlice
	Quotes            QuoteSlice
	RepeatedCommands  RepeatedCommandSlice
	ScheduledCommands ScheduledCommandSlice
	Variables         VariableSlice
}

// NewStruct creates a new relationship struct
func (*channelR) NewStruct() *channelR {
	return &channelR{}
}

// channelL is where Load methods for each relationship are stored.
type channelL struct{}

var (
	channelAllColumns            = []string{"id", "created_at", "updated_at", "user_id", "name", "bot_name", "active", "prefix", "bullet", "ignored", "custom_owners", "custom_mods", "custom_regulars", "cooldown", "last_command_at", "last_fm", "parse_youtube", "extra_life_id", "raffle_enabled", "should_moderate", "display_warnings", "enable_warnings", "timeout_duration", "enable_filters", "filter_links", "permitted_links", "filter_caps", "filter_caps_min_chars", "filter_caps_percentage", "filter_caps_min_caps", "filter_emotes", "filter_emotes_max", "filter_emotes_single", "filter_symbols", "filter_symbols_percentage", "filter_symbols_min_symbols", "filter_me", "filter_max_length", "filter_banned_phrases", "filter_banned_phrases_patterns"}
	channelColumnsWithoutDefault = []string{"user_id", "name", "bot_name", "active", "prefix", "bullet", "cooldown", "last_command_at", "last_fm", "parse_youtube", "extra_life_id", "raffle_enabled", "should_moderate", "display_warnings", "enable_warnings", "timeout_duration", "enable_filters", "filter_links", "filter_caps", "filter_caps_min_chars", "filter_caps_percentage", "filter_caps_min_caps", "filter_emotes", "filter_emotes_max", "filter_emotes_single", "filter_symbols", "filter_symbols_percentage", "filter_symbols_min_symbols", "filter_me", "filter_max_length", "filter_banned_phrases"}
	channelColumnsWithDefault    = []string{"id", "created_at", "updated_at", "ignored", "custom_owners", "custom_mods", "custom_regulars", "permitted_links", "filter_banned_phrases_patterns"}
	channelPrimaryKeyColumns     = []string{"id"}
)

type (
	// ChannelSlice is an alias for a slice of pointers to Channel.
	// This should generally be used opposed to []Channel.
	ChannelSlice []*Channel

	channelQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	channelType                 = reflect.TypeOf(&Channel{})
	channelMapping              = queries.MakeStructMapping(channelType)
	channelPrimaryKeyMapping, _ = queries.BindMapping(channelType, channelMapping, channelPrimaryKeyColumns)
	channelInsertCacheMut       sync.RWMutex
	channelInsertCache          = make(map[string]insertCache)
	channelUpdateCacheMut       sync.RWMutex
	channelUpdateCache          = make(map[string]updateCache)
	channelUpsertCacheMut       sync.RWMutex
	channelUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single channel record from the query.
func (q channelQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Channel, error) {
	o := &Channel{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for channels")
	}

	return o, nil
}

// All returns all Channel records from the query.
func (q channelQuery) All(ctx context.Context, exec boil.ContextExecutor) (ChannelSlice, error) {
	var o []*Channel

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Channel slice")
	}

	return o, nil
}

// Count returns the count of all Channel records in the query.
func (q channelQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count channels rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q channelQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if channels exists")
	}

	return count > 0, nil
}

// Autoreplies retrieves all the autoreply's Autoreplies with an executor.
func (o *Channel) Autoreplies(mods ...qm.QueryMod) autoreplyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"autoreplies\".\"channel_id\"=?", o.ID),
	)

	query := Autoreplies(queryMods...)
	queries.SetFrom(query.Query, "\"autoreplies\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"autoreplies\".*"})
	}

	return query
}

// CustomCommands retrieves all the custom_command's CustomCommands with an executor.
func (o *Channel) CustomCommands(mods ...qm.QueryMod) customCommandQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"custom_commands\".\"channel_id\"=?", o.ID),
	)

	query := CustomCommands(queryMods...)
	queries.SetFrom(query.Query, "\"custom_commands\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"custom_commands\".*"})
	}

	return query
}

// Quotes retrieves all the quote's Quotes with an executor.
func (o *Channel) Quotes(mods ...qm.QueryMod) quoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"quotes\".\"channel_id\"=?", o.ID),
	)

	query := Quotes(queryMods...)
	queries.SetFrom(query.Query, "\"quotes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"quotes\".*"})
	}

	return query
}

// RepeatedCommands retrieves all the repeated_command's RepeatedCommands with an executor.
func (o *Channel) RepeatedCommands(mods ...qm.QueryMod) repeatedCommandQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"repeated_commands\".\"channel_id\"=?", o.ID),
	)

	query := RepeatedCommands(queryMods...)
	queries.SetFrom(query.Query, "\"repeated_commands\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"repeated_commands\".*"})
	}

	return query
}

// ScheduledCommands retrieves all the scheduled_command's ScheduledCommands with an executor.
func (o *Channel) ScheduledCommands(mods ...qm.QueryMod) scheduledCommandQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"scheduled_commands\".\"channel_id\"=?", o.ID),
	)

	query := ScheduledCommands(queryMods...)
	queries.SetFrom(query.Query, "\"scheduled_commands\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"scheduled_commands\".*"})
	}

	return query
}

// Variables retrieves all the variable's Variables with an executor.
func (o *Channel) Variables(mods ...qm.QueryMod) variableQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"variables\".\"channel_id\"=?", o.ID),
	)

	query := Variables(queryMods...)
	queries.SetFrom(query.Query, "\"variables\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"variables\".*"})
	}

	return query
}

// LoadAutoreplies allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadAutoreplies(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		object = maybeChannel.(*Channel)
	} else {
		slice = *maybeChannel.(*[]*Channel)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`autoreplies`), qm.WhereIn(`channel_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load autoreplies")
	}

	var resultSlice []*Autoreply
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice autoreplies")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on autoreplies")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for autoreplies")
	}

	if singular {
		object.R.Autoreplies = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &autoreplyR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.Autoreplies = append(local.R.Autoreplies, foreign)
				if foreign.R == nil {
					foreign.R = &autoreplyR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadCustomCommands allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadCustomCommands(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		object = maybeChannel.(*Channel)
	} else {
		slice = *maybeChannel.(*[]*Channel)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`custom_commands`), qm.WhereIn(`channel_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load custom_commands")
	}

	var resultSlice []*CustomCommand
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice custom_commands")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on custom_commands")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for custom_commands")
	}

	if singular {
		object.R.CustomCommands = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customCommandR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.CustomCommands = append(local.R.CustomCommands, foreign)
				if foreign.R == nil {
					foreign.R = &customCommandR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadQuotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadQuotes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		object = maybeChannel.(*Channel)
	} else {
		slice = *maybeChannel.(*[]*Channel)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`quotes`), qm.WhereIn(`channel_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load quotes")
	}

	var resultSlice []*Quote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice quotes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on quotes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quotes")
	}

	if singular {
		object.R.Quotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &quoteR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.Quotes = append(local.R.Quotes, foreign)
				if foreign.R == nil {
					foreign.R = &quoteR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadRepeatedCommands allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadRepeatedCommands(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		object = maybeChannel.(*Channel)
	} else {
		slice = *maybeChannel.(*[]*Channel)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`repeated_commands`), qm.WhereIn(`channel_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load repeated_commands")
	}

	var resultSlice []*RepeatedCommand
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice repeated_commands")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on repeated_commands")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for repeated_commands")
	}

	if singular {
		object.R.RepeatedCommands = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &repeatedCommandR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.RepeatedCommands = append(local.R.RepeatedCommands, foreign)
				if foreign.R == nil {
					foreign.R = &repeatedCommandR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadScheduledCommands allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadScheduledCommands(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		object = maybeChannel.(*Channel)
	} else {
		slice = *maybeChannel.(*[]*Channel)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`scheduled_commands`), qm.WhereIn(`channel_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load scheduled_commands")
	}

	var resultSlice []*ScheduledCommand
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice scheduled_commands")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on scheduled_commands")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for scheduled_commands")
	}

	if singular {
		object.R.ScheduledCommands = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &scheduledCommandR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.ScheduledCommands = append(local.R.ScheduledCommands, foreign)
				if foreign.R == nil {
					foreign.R = &scheduledCommandR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadVariables allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadVariables(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		object = maybeChannel.(*Channel)
	} else {
		slice = *maybeChannel.(*[]*Channel)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`variables`), qm.WhereIn(`channel_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load variables")
	}

	var resultSlice []*Variable
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice variables")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on variables")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for variables")
	}

	if singular {
		object.R.Variables = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &variableR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.Variables = append(local.R.Variables, foreign)
				if foreign.R == nil {
					foreign.R = &variableR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// AddAutoreplies adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.Autoreplies.
// Sets related.R.Channel appropriately.
func (o *Channel) AddAutoreplies(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Autoreply) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"autoreplies\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, autoreplyPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			Autoreplies: related,
		}
	} else {
		o.R.Autoreplies = append(o.R.Autoreplies, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &autoreplyR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddCustomCommands adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.CustomCommands.
// Sets related.R.Channel appropriately.
func (o *Channel) AddCustomCommands(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomCommand) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"custom_commands\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, customCommandPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			CustomCommands: related,
		}
	} else {
		o.R.CustomCommands = append(o.R.CustomCommands, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customCommandR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddQuotes adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.Quotes.
// Sets related.R.Channel appropriately.
func (o *Channel) AddQuotes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Quote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"quotes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			Quotes: related,
		}
	} else {
		o.R.Quotes = append(o.R.Quotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &quoteR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddRepeatedCommands adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.RepeatedCommands.
// Sets related.R.Channel appropriately.
func (o *Channel) AddRepeatedCommands(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RepeatedCommand) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"repeated_commands\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, repeatedCommandPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			RepeatedCommands: related,
		}
	} else {
		o.R.RepeatedCommands = append(o.R.RepeatedCommands, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &repeatedCommandR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddScheduledCommands adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.ScheduledCommands.
// Sets related.R.Channel appropriately.
func (o *Channel) AddScheduledCommands(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ScheduledCommand) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"scheduled_commands\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, scheduledCommandPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			ScheduledCommands: related,
		}
	} else {
		o.R.ScheduledCommands = append(o.R.ScheduledCommands, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &scheduledCommandR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddVariables adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.Variables.
// Sets related.R.Channel appropriately.
func (o *Channel) AddVariables(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Variable) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"variables\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, variablePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			Variables: related,
		}
	} else {
		o.R.Variables = append(o.R.Variables, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &variableR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// Channels retrieves all the records using an executor.
func Channels(mods ...qm.QueryMod) channelQuery {
	mods = append(mods, qm.From("\"channels\""))
	return channelQuery{NewQuery(mods...)}
}

// FindChannel retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindChannel(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*Channel, error) {
	channelObj := &Channel{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"channels\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, channelObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from channels")
	}

	return channelObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Channel) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no channels provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(channelColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	channelInsertCacheMut.RLock()
	cache, cached := channelInsertCache[key]
	channelInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			channelAllColumns,
			channelColumnsWithDefault,
			channelColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(channelType, channelMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(channelType, channelMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"channels\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"channels\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into channels")
	}

	if !cached {
		channelInsertCacheMut.Lock()
		channelInsertCache[key] = cache
		channelInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Channel.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Channel) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	key := makeCacheKey(columns, nil)
	channelUpdateCacheMut.RLock()
	cache, cached := channelUpdateCache[key]
	channelUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			channelAllColumns,
			channelPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update channels, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"channels\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, channelPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(channelType, channelMapping, append(wl, channelPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update channels row")
	}

	if !cached {
		channelUpdateCacheMut.Lock()
		channelUpdateCache[key] = cache
		channelUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q channelQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for channels")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ChannelSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), channelPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"channels\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, channelPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in channel slice")
	}

	return nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Channel) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no channels provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(channelColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	channelUpsertCacheMut.RLock()
	cache, cached := channelUpsertCache[key]
	channelUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			channelAllColumns,
			channelColumnsWithDefault,
			channelColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			channelAllColumns,
			channelPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert channels, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(channelPrimaryKeyColumns))
			copy(conflict, channelPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"channels\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(channelType, channelMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(channelType, channelMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert channels")
	}

	if !cached {
		channelUpsertCacheMut.Lock()
		channelUpsertCache[key] = cache
		channelUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Channel record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Channel) Delete(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil {
		return errors.New("models: no Channel provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), channelPrimaryKeyMapping)
	sql := "DELETE FROM \"channels\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from channels")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q channelQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if q.Query == nil {
		return errors.New("models: no channelQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from channels")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ChannelSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), channelPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"channels\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, channelPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from channel slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Channel) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindChannel(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ChannelSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ChannelSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), channelPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"channels\".* FROM \"channels\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, channelPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ChannelSlice")
	}

	*o = slice

	return nil
}

// ChannelExists checks if the Channel row exists.
func ChannelExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"channels\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if channels exists")
	}

	return exists, nil
}
